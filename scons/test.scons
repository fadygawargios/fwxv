from scons.common import parse_config
import subprocess
import serial  # pip install pyserial
from pathlib import Path

Import('VARS')

TYPE = VARS.get("TYPE")
TARGET = VARS.get("TARGET")
PLATFORM = VARS.get("PLATFORM")
env = VARS.get("env")


def src(path):
    # return all source files within a path
    srcs = []
    for file in path.glob("src/*.[cs]") + path.glob(f"src/{PLATFORM}/*.[cs]"):
        srcs.append(OBJ_DIR.File(file.path))
    return srcs


def inc(path):
    # return all include directories within a path
    return [path.Dir("inc"), path.Dir("inc").Dir(PLATFORM)]


def get_lib_deps(entry):
    # Recursively get library dependencies for entry
    config = parse_config(entry)
    deps = config['libs'] + config['{}_libs'.format(PLATFORM)]
    for dep in deps:
        deps += get_lib_deps(LIB_DIR.Dir(dep))
    return deps


def lib_bin(lib_name):
    return BIN_DIR.Dir(LIB_DIR.name).File('lib{}.a'.format(lib_name))

# ELFs are used for gdb and x86


def proj_elf(proj_name, is_smoke=False):
    return BIN_DIR.Dir(SMOKE_DIR.name if is_smoke else PROJ_DIR.name).File(proj_name)

# .bin is used for flashing to MCU


def proj_bin(proj_name, is_smoke=False):
    return proj_elf(proj_name, is_smoke).File(proj_name + '.bin')


ROOT = Dir('#')

BUILD_DIR = ROOT.Dir('build').Dir(PLATFORM)
BIN_DIR = BUILD_DIR.Dir('bin')
OBJ_DIR = BUILD_DIR.Dir('obj')
TEST_DIR = BUILD_DIR.Dir('test')

PROJ_DIR = ROOT.Dir('projects')
LIB_DIR = ROOT.Dir('libraries')
SMOKE_DIR = ROOT.Dir('smoke')
CAN_DIR = ROOT.Dir('can')

PROJ_DIRS = list(PROJ_DIR.glob('*'))
LIB_DIRS = list(LIB_DIR.glob('*'))
SMOKE_DIRS = list(SMOKE_DIR.glob('*'))

LIB_BIN_DIR = BIN_DIR.Dir('libraries')

PLATFORM_DIR = ROOT.Dir('platform')

CODEGEN_DIR = LIB_DIR.Dir("codegen")
BOARDS_DIR = CODEGEN_DIR.Dir("boards")
GENERATOR = CODEGEN_DIR.File("generator.py")
TEMPLATES_DIR = CODEGEN_DIR.Dir("templates")

LIBRARIES_INC_DIR = LIB_DIR.Dir("ms-common").Dir("inc")

GEN_RUNNER = 'libraries/unity/auto/generate_test_runner.py'
GEN_RUNNER_CONFIG = 'libraries/unity/unity_config.yml'

# tests dict maps proj/lib -> list of their test executables
tests = {}


def addBuildPath(string: str):
    if (not string.startswith('build')):
        return f"#/{OBJ_DIR.path}/{string}"
    else:
        return f"#/{string}"


lib_incs = [inc(lib_dir) for lib_dir in LIB_DIR.glob('*')]
# Create the test executable targets
for entry in PROJ_DIRS + LIB_DIRS + SMOKE_DIRS:
    tests[entry.name] = []
    for test_file in entry.glob('test/*.c'):
        # Link runner object, test file object, and proj/lib objects
        # into executable
        config = parse_config(entry)
        test_module_name = Path(test_file.path).stem

        mocks = config.get("mocks", {}).get(test_module_name, [])
        mock_link_flags = [('-Wl,-wrap,' + mock) for mock in mocks]

        objs = src(entry)
        inc_dirs = inc(entry)

        if config["can"]:
            inc_dirs += inc(OBJ_DIR.Dir(f"{entry.path}/can"))
            inc_dirs += inc(ROOT.Dir("can"))
            objs += OBJ_DIR.glob(f"{entry.path}/src/*.[cs]") + OBJ_DIR.glob(f"{entry.path}/src/{PLATFORM}/*.[cs]")

        entry_objects = list(filter(lambda o: "main" not in o.name, objs))

        print([f.path for f in inc_dirs])

        lib_deps = get_lib_deps(entry)

        # Create the *_runner.c file
        runner_file = TEST_DIR.File(
            f"{entry.path}/{test_module_name}_runner.c")
        test_runner = env.Command(runner_file, test_file,
                                  f'python3 {GEN_RUNNER} {GEN_RUNNER_CONFIG} $SOURCE $TARGET')

        output = TEST_DIR.Dir(f"{entry.path}/{test_module_name}")
        srcs = [test_file, test_runner] + entry_objects


        target = env.Program(
            target=output,
            source=srcs,
            # We do env['variable'] + [entry-specific variables] to avoid
            # mutating the environment for other entries
            CPPPATH=env['CPPPATH'] + inc_dirs + lib_incs,
            LIBS=env['LIBS'] + lib_deps * 2 + ['unity'],
            LIBPATH=[LIB_BIN_DIR],
            CCFLAGS=env['CCFLAGS'] + config['cflags'],
            LINKFLAGS=env['LINKFLAGS'] + mock_link_flags,
        )
        if PLATFORM == 'arm':
            target = env.Bin(target=output.File(
                test_file.name + '.bin'), source=target)

        # Make test executable depend on the project / library final target
        if entry in PROJ_DIRS:
            Depends(target, proj_elf(entry.name, entry in SMOKE_DIRS))
        elif entry in LIB_DIRS:
            Depends(target, lib_bin(entry.name))

        # Add to tests dict
        tests[entry.name] += [node for node in target]


def get_test_list():
    # Based on the project/library and test in options,
    # create a list of tests to run
    # Assume only one of project or library is set
    entry = TARGET
    if entry and tests.get(entry):
        if GetOption('testfile'):
            return [test for test in tests[entry] if (test.name + '.').startswith(f"test_{GetOption('testfile')}.")]
        else:
            return [test for test in tests[entry]]
    else:
        ret = []
        for test_list in tests.values():
            ret += test_list
        return ret
    


def test_runner(target, source, env):
    test_list = get_test_list()

    if PLATFORM == "arm":
        # startup usb serial communication with mcu
        output = subprocess.check_output(["ls", "/dev/serial/by-id/"])
        device_path = f"/dev/serial/by-id/{str(output, 'ASCII').strip()}"
        serialData = serial.Serial(device_path, 115200)

    fails = 0
    for test in test_list:
        if PLATFORM == "x86":
            test_process = subprocess.run(test.get_path())
            fails += (test_process.returncode != 0)

        elif PLATFORM == "arm":
            OPENOCD = 'openocd'
            OPENOCD_SCRIPT_DIR = '/usr/share/openocd/scripts/'
            PROBE = 'cmsis-dap'
            OPENOCD_CFG = [
                OPENOCD,
                '-s {}'.format(OPENOCD_SCRIPT_DIR),
                '-f interface/{}.cfg'.format(PROBE),
                '-f target/stm32f1x.cfg',
                '-f {}/stm32f1-openocd.cfg'.format(PLATFORM_DIR),
                '-c "stm32f1x.cpu configure -rtos FreeRTOS"',
                '-c "stm_flash {}"'.format(test),
                '-c shutdown'
            ]
            cmd = 'sudo {}'.format(' '.join(OPENOCD_CFG))
            print(f"Flashing {test}")
            subprocess.run(cmd, shell=True,
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            print(f"Starting {test}")

            # wait until test ok or fail
            while True:
                line: str = serialData.readline().decode("utf-8")
                print(line, end='')
                if line.startswith('OK'):
                    break
                if line.startswith('FAIL'):
                    fails += 1
                    break

    print(f"{len(test_list)} Files tested {fails} Failures")


test = Command('#/test', [], test_runner)
Depends(test, get_test_list())
