from scons.common import parse_config, flash_run
import subprocess
import serial  # pip install pyserial
from pathlib import Path

Import('VARS')

TARGET = VARS.get("TARGET")
PLATFORM = VARS.get("PLATFORM")
env = VARS.get("env")

ROOT = Dir('#')

BUILD_DIR = ROOT.Dir('build').Dir(PLATFORM)
BIN_DIR = BUILD_DIR.Dir('bin')
OBJ_DIR = BUILD_DIR.Dir('obj')
TEST_DIR = BUILD_DIR.Dir('test')

PROJ_DIR = ROOT.Dir('projects')
LIB_DIR = ROOT.Dir('libraries')
SMOKE_DIR = ROOT.Dir('smoke')

GEN_RUNNER = 'libraries/unity/auto/generate_test_runner.py'
GEN_RUNNER_CONFIG = 'libraries/unity/unity_config.yml'


def run_test(target, source, env):
    fails = 0
    for test in source:
        if PLATFORM == "x86":
            test_process = subprocess.run(test.path)
            fails += (test_process.returncode != 0)

        elif PLATFORM == "arm":
            serialData = flash_run(test)

            # wait until test ok or fail
            while True:
                line: str = serialData.readline().decode("utf-8")
                print(line, end='')
                if line.startswith('OK'):
                    break
                if line.startswith('FAIL'):
                    fails += 1
                    break

    print(f"{len(source)} Files tested {fails} Failures")


###########################################################
# Create appropriate test targets, (when lib/proj target is defined)
###########################################################
def add_test_targets(target, source, env):
    entry = ROOT.Dir(Path(target[0].path).relative_to(BIN_DIR.path))
    config = parse_config(entry)

    if entry.path.startswith("libraries"):
        # libraries target will look like libraries/lib[name].a
        # extract the name and convert to the directory of the actual library
        entry = ROOT.Dir(f"libraries/{entry.name[3:-2]}")
    # non-libraries has a main.o that needs to be removed from the source for tests
    sources_no_main = list(filter(lambda f: f.name != "main.o", source))

    # create target for every test
    for test_file in entry.glob('test/*.c'):
        test_module_name = Path(test_file.path).stem

        mocks = config.get("mocks", {}).get(test_module_name, [])
        mock_link_flags = [f'-Wl,-wrap,{mock}' for mock in mocks]

        runner_exec = TEST_DIR.File(f"{entry.path}/bin/{test_module_name}")

        runner_file = TEST_DIR.File(test_file.path)
        runner_file = env.Command(
            runner_file,
            [test_file, ROOT.Dir("libraries/unity/auto").glob("*")],
            f'python3 {GEN_RUNNER} {GEN_RUNNER_CONFIG} {test_file.path} {runner_file.path}')
        test_sources = [runner_file, OBJ_DIR.File(test_file.path)]

        test_target = env.Program(
            target=runner_exec,
            source=sources_no_main + test_sources,
            CPPPATH=env['CPPPATH'],
            LIBS=env['LIBS'] + ['unity'],
            LIBPATH=env['LIBPATH'],
            CCFLAGS=env['CCFLAGS'],
            LINKFLAGS=env['LINKFLAGS'] + mock_link_flags,
            PROGEMITTER=None,  # don't trigger emitter recursively
        )

        if PLATFORM == 'arm':
            test_target = env.Bin(target=ROOT.File(runner_exec.path+'.bin'),
                                  source=test_target)
        env.Command(f"test/{entry.path}/{test_module_name}",
                    test_target, run_test)
    # target and source are not modified
    # this emitter only adds the test targets based on the project/library's inc + src
    return target, source


env.Append(PROGEMITTER=add_test_targets)
env.Append(LIBEMITTER=add_test_targets)
# generate all test target names
all_tests = []
for entry in PROJ_DIR.glob('*') + LIB_DIR.glob('*') + SMOKE_DIR.glob('*'):
    tests = []
    for test_file in entry.glob('test/*.c'):
        test_module_name = Path(test_file.path).stem
        tests.append(f"test/{entry.path}/{test_module_name}")
    env.Alias(f"test/{entry.path}", tests)
    all_tests += tests

TARGET = str(Path("test", TARGET or '', GetOption("testfile") or ""))
selected_tests = list(filter(lambda t: t.startswith(TARGET), all_tests))
Command("#/test", selected_tests, "")
